package baeume;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;

import _config.Configuration;

/**
 * This code was edited or generated using CloudGarden's Jigloo SWT/Swing GUI
 * Builder, which is free for non-commercial use. If Jigloo is being used
 * commercially (ie, by a corporation, company or business for any purpose
 * whatever) then you should purchase a license for each developer using Jigloo.
 * Please visit www.cloudgarden.com for details. Use of Jigloo implies
 * acceptance of these licensing terms. A COMMERCIAL LICENSE HAS NOT BEEN
 * PURCHASED FOR THIS MACHINE, SO JIGLOO OR THIS CODE CANNOT BE USED LEGALLY FOR
 * ANY CORPORATE OR COMMERCIAL PURPOSE.
 */

public class TreeViewer extends javax.swing.JFrame {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	
	private BinaryTree<?> root;
	private javax.swing.JPanel canvas;


	private BinaryTree<?> highlightedTree;
	private String highlightedTreeContentString;
	private String repaintMonitorObject = "repaintMonitor";



	private static Font font = new Font("Serif", Font.BOLD, 14);

	private static TreeViewer TREE_VIEWER_SINGLETON;

	private static boolean DO_HIGHLIGHT = false;
	private boolean DO_HIGHLIGHT_NODE = false;


	
	private TreeViewer(int width, int height) {
		super();
		initGUI(width,height);
	}

	private static void warte(int millis) {
		try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	public static void showTree(){
		if(TREE_VIEWER_SINGLETON == null){
			return;
		}
		DO_HIGHLIGHT = false;
		synchronized(TREE_VIEWER_SINGLETON.repaintMonitorObject){
			TREE_VIEWER_SINGLETON.repaint();
			warte(Configuration.WARTEZEIT_BAEUME);
			DO_HIGHLIGHT = true;
		}
	}
	
	public static void showTree(BinaryTree<?> pTree, int width, int height) {
		if (TREE_VIEWER_SINGLETON == null) {
			TREE_VIEWER_SINGLETON = new TreeViewer(width, height);
		}		
		if(TREE_VIEWER_SINGLETON == null){
			return;
		}
		TREE_VIEWER_SINGLETON.setBinaryTree(pTree);
		TREE_VIEWER_SINGLETON.setVisible(true);
		showTree();
	}

	public static void showTree(BinarySearchTree<?> pSearchTree, int width, int height) {
		showTree(pSearchTree.getBinaryTree(), width, height);
	}
	
	public void highlight(BinaryTree<?> pTree, String pTreeContentString ){
		if(DO_HIGHLIGHT){
			synchronized(TreeViewer.this.repaintMonitorObject){
				TreeViewer.this.highlightedTree = pTree;
				TreeViewer.this.highlightedTreeContentString = pTreeContentString;
				new HighlightThread(true).start();				
				try {
					TreeViewer.this.repaintMonitorObject.wait();
				} catch (InterruptedException e) {
					System.out.println(e.getMessage());
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			warte(Configuration.WARTEZEIT_BAEUME);
			synchronized(TreeViewer.this.repaintMonitorObject){
				TreeViewer.this.highlightedTree = pTree;
				TreeViewer.this.highlightedTreeContentString = pTreeContentString;
				new HighlightThread(false).start();
				try {
					TreeViewer.this.repaintMonitorObject.wait();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}		
	}
	
	public static TreeViewer getSingleton(){
		return TREE_VIEWER_SINGLETON;
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initGUI(int width, int height) {
		BorderLayout layout = new BorderLayout();
		getContentPane().setLayout(layout);
		canvas = new javax.swing.JPanel();
		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		canvas.setBackground(new java.awt.Color(255, 255, 51));
		this.setSize(width,height);
		this.setPreferredSize(new java.awt.Dimension(width,height));
		this.getContentPane().add(canvas, BorderLayout.CENTER);
		this.setLocation(250, 0);
		pack();

	}

	private void zeichnen(Graphics g, BinaryTree<?> b, int l, int r, int t) {
		g.setFont(font);
		if (b != null && !b.isEmpty()) {
			String s = b.getContent().toString();
			// System.out.println(s);
			int x = (int) ((l + r - s.length() * 7) / 2);
			g.setColor(Color.BLUE);
			g.drawString(s, x, t * 36);
			int x1 = (int) ((l + r) / 2);
			int y1 = t * 36 + 7;
			int x2 = (int) ((l + x1) / 2);
			int x3 = (int) ((x1 + r) / 2);
			int y2 = y1 + 36;
			g.setColor(Color.RED);
			if (b.getLeftTree() != null && !b.getLeftTree().isEmpty())
				g.drawLine(x1, y1, x2, y2);
			if (b.getRightTree() != null && !b.getRightTree().isEmpty())
				g.drawLine(x1, y1, x3, y2);
			g.fillOval(x1 - 3, y1 - 3, 6, 6);
			zeichnen(g, b.getLeftTree(), l, (int) (l + r) / 2, t + 1);
			zeichnen(g, b.getRightTree(), (int) (l + r) / 2, r, t + 1);
		}
		
	}

	/**
	 * zeigt den BinaryTree b bzw. rekursiv eines seiner Kinder als highlighted an.
	 * Voraussetzung: b == this.highlightedTree
	 * @param g
	 * @param b
	 * @param l
	 * @param r
	 * @param t
	 * @param highlighted
	 */
	private void highlightNode(Graphics g, BinaryTree<?> b, int l, int r, int t, boolean highlighted) {
		if(highlightedTree == null){
			return;
		}
		g.setFont(font);
		if (b != null && !b.isEmpty()) {
			if(b == this.highlightedTree){
				String s = this.highlightedTreeContentString;
				if(highlighted){
					g.setColor(Color.RED);
				}
				else{
					g.setColor(Color.BLUE);
				}
				int x = (int) ((l + r - s.length() * 7) / 2);
				g.drawString(s, x, t * 36);
				warte(Configuration.WARTEZEIT_BAEUME);
			}
			int x1 = (int) ((l + r) / 2);
			int y1 = t * 36 + 7;
			highlightNode(g, b.getLeftTree(), l, (int) (l + r) / 2, t + 1, highlighted);
			highlightNode(g, b.getRightTree(), (int) (l + r) / 2, r, t + 1, highlighted);
		}
		
	}

	private void setBinaryTree(BinaryTree<?> baum) {
		root = baum;
		DO_HIGHLIGHT = false;
		repaint();
		//DO_HIGHLIGHT = true;
	}

	private void setBinarySearchTree(BinarySearchTree<?> bst) {
		setBinaryTree(bst.getBinaryTree());
	}

	@Override
	public void paint(Graphics g) {
		synchronized(this.repaintMonitorObject){
			if(DO_HIGHLIGHT && this.highlightedTreeContentString != null){
					// nur einen Knoten highlighten
					//System.out.println("paint highlight: "+this.highlightedTreeContentString+": "+DO_HIGHLIGHT_NODE);
					g.translate(0, 15);	
					highlightNode(g, root,1,canvas.getWidth(),1, DO_HIGHLIGHT_NODE);
					this.highlightedTree = null;
					this.highlightedTreeContentString = null;
					this.repaintMonitorObject.notify();
			}
			else{
					// ganzen Baum zeichnen
					//System.out.println("Baum neu zeichnen");
					DO_HIGHLIGHT = false;
					super.paint(g);
					g.translate(0, 15);			
					g.setColor(Color.YELLOW);
					g.fillRect(0, 0, canvas.getSize().width, canvas.getSize().height);
					zeichnen(g, root, 1, canvas.getWidth(), 1);
					DO_HIGHLIGHT = true;
					this.repaintMonitorObject.notify();
			}
		}

	}
	
	private class HighlightThread extends Thread{
		private boolean doHighlight;

		HighlightThread(boolean doHighlight){
			this.doHighlight = doHighlight;
		}
		
		public void run(){
			TreeViewer.this.DO_HIGHLIGHT_NODE = doHighlight;
			//System.out.println("HighlightThread: "+highlightedTreeContentString+": "+doHighlight);
			repaint();
		}
	}

}
